/*
 * Copyright (c) 2014 mgm technology partners GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import org.apache.commons.lang3.StringUtils
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry
import org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream
import org.apache.commons.compress.archivers.zip.ZipFile
import org.apache.commons.io.IOUtils
import org.apache.tools.ant.taskdefs.condition.Os

buildscript {
	dependencies {
		classpath fileTree(dir: 'lib')
	}
}

repositories {
	mavenLocal()
	mavenCentral()
}

configurations {
	distro {
		description = 'perfLoad Distributions'
		transitive = false
	}
}

dependencies {
	def distros = [
		[g: 'com.mgmtp.perfload.core', a: 'perfload-console', v: '4.8.0'],
		[g: 'com.mgmtp.perfload.core', a: 'perfload-client', v: '4.8.0'],
		[g: 'com.mgmtp.perfload.core', a: 'perfload-daemon', v: '4.8.0'],
		[g: 'com.mgmtp.perfload.agent', a: 'perfload-agent', v: '1.4.1'],
		[g: 'com.mgmtp.perfload.perfmon', a: 'perfload-perfmon', v: '2.3.0'],
		[g: 'com.mgmtp.perfload.perfalyzer', a: 'perfload-perfalyzer', v: '1.1.0'],
		[g: 'com.mgmtp.perfload.refapp', a: 'perfload-refapp', v: '1.0.2'],
		[g: 'com.mgmtp.perfload.supervisor', a: 'perfload-supervisor', v: '2.1.0'],
		[g: 'com.mgmtp.perfload.loadprofiles', a: 'perfload-loadprofiles', v: '1.3.0']
	]
	distros.each { map ->
		distro "${map.g}:${map.a}:${map.v}:dist@zip"
	}
}

defaultTasks 'setup'

task setup << {
	welcome()
	init()

	if (project.hasProperty('perfloadHome')) {
		unzipDistributions()
		configureDistributions()
		println 'perfLoad demo setup installation finished.'
	}
}

def welcome() {
	int len = 65
	String copyright = StringUtils.center('(c) 2013, mgm technology partners GmbH', len)
	String welcomeMsg = StringUtils.center('Welcome to perfLoad\'s Demo Installer ${project.version}', len)

	List list1 = []
	(len + 2).times { list1 << '*' }
	String msg1 = list1.join()

	List list2 = ['*']
	len.times { list2 << ' ' }
	list2 << '*'
	String msg2 = list2.join()

	String message = """
	$msg1
	$msg2
	$msg2
	*${welcomeMsg}*
	*${copyright}*
	$msg2
	$msg2
	$msg1
	"""

	println message
}

def init() {
	def console = new Console()
	def perfloadHome = console.readLine ' > Enter installation directory [../perfload-demo]: '
	if (!perfloadHome) {
		perfloadHome = '../perfload-demo'
	}

	def dir = file(perfloadHome)
	if (dir.exists() && dir.list().length > 0) {
		def deleteHome = console.readLine ' > Directory already exists and is not empty. Delete [Y/n]? '
		if ('y'.equalsIgnoreCase(StringUtils.defaultIfEmpty(deleteHome, 'y'))) {
			delete perfloadHome
		} else {
			println 'Cannot proceed due to existing installation directory. Exiting!'
			return
		}
	}
	dir.mkdirs()
	project.ext.perfloadHome = perfloadHome
}

def unzipDistributions() {
	println 'Downloading and unzipping perfLoad distributions...'
	configurations.distro.each { zip ->
		println "\t${zip.name}"

		// we need to use commons-compress in order to restore Unix permissions
		unzip(file(zip), perfloadHome)
	}
}

def unzip(final File zipFile, final String destDir) {
	final ZipFile zip = new ZipFile(zipFile)
	try	{
		for (Enumeration<? extends ZipArchiveEntry> entries = zip.getEntries(); entries.hasMoreElements();) {
			ZipArchiveEntry zipEntry = entries.nextElement()
			File file = new File(destDir, zipEntry.getName())
			if (zipEntry.isDirectory())	{
				file.mkdirs()
				continue
			}
			if (!file.getParentFile().exists())	{
				file.getParentFile().mkdirs()
			}

			InputStream is = null
			OutputStream fos = null
			try	{
				is = zip.getInputStream(zipEntry)
				fos = new FileOutputStream(file)
				IOUtils.copy(is, fos)

				// check for user-executable bit on entry and apply to file
				if ((zipEntry.getUnixMode() & 0100) != 0) {
					file.setExecutable(true)
				}
				file.setLastModified(zipEntry.getTime())
			} finally {
				IOUtils.closeQuietly(is)
				IOUtils.closeQuietly(fos)
			}
		}
	} finally {
		try	{
			zip.close()
		} catch (IOException e)	{
			// ignore
		}
	}
}

def configureDistributions() {
	println 'Configuring installation...'

	copy {
		from 'demo-setup'
		into perfloadHome
	}

	ant.delete {
		fileset(dir: perfloadHome) {
			include(name: '**/*_Default.*')
			include(name: '**/*.default.*')
			if (Os.isFamily(Os.FAMILY_WINDOWS)) {
				include(name: '**/*_unix.*')
			} else {
				include(name: '**/*_windows.*')
			}
		}
	}

	def family = Os.isFamily(Os.FAMILY_WINDOWS) ? 'windows' : 'unix'
	ant.move(
		file: "${perfloadHome}/supervisor/conf/LoadTestConfig_${family}.groovy",
		tofile: "${perfloadHome}/supervisor/conf/LoadTestConfig.groovy"
	)
}

class Console {

	private final java.io.Console console
	private BufferedReader oldFashionedReader

	Console() {
		console = System.console()
		if (console == null) {
			oldFashionedReader = new BufferedReader(new InputStreamReader(System.in))
		}
	}

	String readLine(String prompt) {
		if (console != null) {
			return console.readLine(prompt)
		} else {
			try {
				println(prompt)
				return oldFashionedReader.readLine()
			} catch (IOException ex) {
				// can't really happen
				throw new UncheckedIOException(ex)
			}
		}
	}
}
